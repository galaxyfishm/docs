(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{522:function(a,t,s){"use strict";s.r(t);var _=s(7),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"一、关系型数据库特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、关系型数据库特点"}},[a._v("#")]),a._v(" 一、关系型数据库特点")]),a._v(" "),s("ul",[s("li",[a._v("基于行存储数据，二维的模式；")]),a._v(" "),s("li",[a._v("存储结构化的数据，数据存储有固定模式（schema）；")]),a._v(" "),s("li",[a._v("表与表之间存在关联；")]),a._v(" "),s("li",[a._v("大都支持SQL（结构化查询语言）的操作，支持复杂的关联查询；")]),a._v(" "),s("li",[a._v("通过支持事务ACID来提供严格或实时的数据一致性；")])]),a._v(" "),s("p",[s("strong",[a._v("缺点：")])]),a._v(" "),s("ul",[s("li",[a._v("要实现扩容的话，只能向上（垂直）扩容，不支持动态扩缩容；")]),a._v(" "),s("li",[a._v("表结构修改困难，因此存储的数据格式也受到限制；")]),a._v(" "),s("li",[a._v("高并发情况下，基于磁盘的读写压力比较大；")])]),a._v(" "),s("h2",{attrs:{id:"dml、ddl、dcl区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dml、ddl、dcl区别"}},[a._v("#")]),a._v(" DML、DDL、DCL区别")]),a._v(" "),s("p",[a._v("**DML(data manipulation language)：**它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。")]),a._v(" "),s("p",[a._v("**DDL(data definition language)：**DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表(TABLE)的结构，数据类型，表之间的链接和约束等初始化工作上，")]),a._v(" "),s("p",[a._v("​\t\t\t\t\t\t\t\t\t\t\t\t\t   他们大多在建立表时使用。")]),a._v(" "),s("p",[a._v("**DCL(Data Control Language)：**是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括(grant,deny,revoke等)语句。在默认状态下，只有sysadmin,dbcreator,db_owner或")]),a._v(" "),s("p",[a._v("​\t\t\t\t\t\t\t\t\t\t\t\t\tdb_securityadmin 等人员才有权力执行DCL。")]),a._v(" "),s("h1",{attrs:{id:"二、初识mysql"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、初识mysql"}},[a._v("#")]),a._v(" 二、初识MySQL")]),a._v(" "),s("p",[a._v("MySQL服务端默认最大连接数151。")]),a._v(" "),s("p",[s("strong",[a._v("客户端与服务端连接：")])]),a._v(" "),s("ul",[s("li",[a._v("通信类型：同步、异步；")]),a._v(" "),s("li",[a._v("连接方式：长连接、短连接；")]),a._v(" "),s("li",[a._v("协议：TCP、Unix Socket；")])]),a._v(" "),s("h2",{attrs:{id:"_1-mysql架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql架构"}},[a._v("#")]),a._v(" 1. MySQL架构")]),a._v(" "),s("h3",{attrs:{id:"_1-架构分层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-架构分层"}},[a._v("#")]),a._v(" 1. 架构分层")]),a._v(" "),s("p",[a._v("MySQL可以分为三层，连接层（跟客户对接）、服务端（执行操作）、存储引擎（提供数据支持）。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210705215733188.png",alt:"image-20210705215733188"}}),a._v(" "),s("h2",{attrs:{id:"_2-执行查询语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-执行查询语句"}},[a._v("#")]),a._v(" 2. 执行查询语句")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210704073035206.png",alt:"image-20210704073035206"}}),a._v(" "),s("h3",{attrs:{id:"_1-1-连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-连接"}},[a._v("#")]),a._v(" 1.1 连接")]),a._v(" "),s("p",[a._v("MySQL服务默认监听端口是3306，**客户端与服务端连接方式有很多：**通信类型：同步、异步；连接方式：长连接、短连接；协议：TCP、Unix Socket；")]),a._v(" "),s("p",[a._v("客户端每产生一个连接或者会话，在服务端就会创建一个线程来处理。反过来如果要杀死会话，就是kill线程。MySQL会把长时间不活动的连接自动断开。")]),a._v(" "),s("p",[a._v("MySQL允许的最大连接数：默认151，最大可以设置为10000。")]),a._v(" "),s("h3",{attrs:{id:"_1-2-查询缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-查询缓存"}},[a._v("#")]),a._v(" 1.2 查询缓存")]),a._v(" "),s("p",[a._v("MySQL内部自带了一个缓存模块。默认是关闭的，并且不推荐使用。")]),a._v(" "),s("h3",{attrs:{id:"_1-3-语法解析和预处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-语法解析和预处理"}},[a._v("#")]),a._v(" 1.3 语法解析和预处理")]),a._v(" "),s("p",[a._v("MySQL的Parser解析器和Preprocesser预处理模块。主要对语句基于SQL语法进行词法解析、语法解析、语义解析。")]),a._v(" "),s("h4",{attrs:{id:"词法解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法解析"}},[a._v("#")]),a._v(" 词法解析")]),a._v(" "),s("p",[a._v("把一个完整的SQL语句打碎成一个个单词。")]),a._v(" "),s("h4",{attrs:{id:"语法解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法解析"}},[a._v("#")]),a._v(" 语法解析")]),a._v(" "),s("p",[a._v("对SQL做一些语法检查，然后根据MySQL定义的语法规则，生成一个数据结构。解析树（select_lex）：")]),a._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210704074720201.png",alt:"image-20210704074720201"}}),a._v(" "),s("p",[a._v("词法语法解析是一个非常基础的功能，Java的编译器，百度搜索引擎如果要识别语句，必须也要有词法语法分析功能。")]),a._v(" "),s("h4",{attrs:{id:"预处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预处理"}},[a._v("#")]),a._v(" 预处理")]),a._v(" "),s("p",[a._v("在解析SQL的环节里有个预处理器，检查生成的解析树，例如：检查表和列名是否存在，检查名字和别名保证没有歧义。")]),a._v(" "),s("h3",{attrs:{id:"_1-4-查询优化器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-查询优化器"}},[a._v("#")]),a._v(" 1.4 查询优化器")]),a._v(" "),s("p",[a._v("一条SQL语句可以有很多中执行方式，如何选择一条最优执行，这就是查询优化器所做的工作。")]),a._v(" "),s("p",[a._v("查询优化器根据解析树生成不同的执行计划，然后选择一种最优的执行计划，MySQL使用基于开销的优化器，选择执行计划开销最小的。查看命令开销：")]),a._v(" "),s("p",[s("code",[a._v("show status like 'Last_query_cost'")])]),a._v(" "),s("p",[s("strong",[a._v("优化类型：")])]),a._v(" "),s("ul",[s("li",[a._v("子查询优化；")]),a._v(" "),s("li",[a._v("等价谓词重写；")]),a._v(" "),s("li",[a._v("条件简化；")]),a._v(" "),s("li",[a._v("外连接消除；")]),a._v(" "),s("li",[a._v("嵌套连接消除；")]),a._v(" "),s("li",[a._v("连接的消除；")]),a._v(" "),s("li",[a._v("语义优化；")]),a._v(" "),s("li",[a._v("非SPJ优化；")])]),a._v(" "),s("p",[a._v("优化器最终会把解析树变成一个"),s("strong",[a._v("查询执行计划")]),a._v("，即一个数据结构。")]),a._v(" "),s("h3",{attrs:{id:"_1-5-执行引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-执行引擎"}},[a._v("#")]),a._v(" 1.5 执行引擎")]),a._v(" "),s("p",[a._v("执行引擎处理执行计划，调用存储引擎提供的统一API，最后把数据返回给客户端。如果开启缓存，同时把写入缓存。")]),a._v(" "),s("h3",{attrs:{id:"_1-6-存储引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-存储引擎"}},[a._v("#")]),a._v(" 1.6 存储引擎")]),a._v(" "),s("p",[a._v("存储引擎类型：InnoDB、Memory、MyISAM等，并且可以自己实现。")]),a._v(" "),s("p",[a._v("各种存储引擎提供了统一的API，使得执行引擎调用变得简单，所以对于表的存储引擎类型可以进行修改。")]),a._v(" "),s("p",[a._v("**MyISAM特点：**表级锁限制了读写性能，常用于以只读为主的工作。")]),a._v(" "),s("ul",[s("li",[a._v("表级别锁，不支持事务。")]),a._v(" "),s("li",[a._v("拥有较高插入和查询速度。")]),a._v(" "),s("li",[a._v("存储了表的行数（count更快）。")])]),a._v(" "),s("p",[a._v("**InnoDB特点：**事务安全的引擎，支持行级锁，将数据存储在聚集索引中，还支持外键引用完整性约束。")]),a._v(" "),s("ul",[s("li",[a._v("支持事务，支持外键，因此数据的完整性、一致性更高。")]),a._v(" "),s("li",[a._v("支持行级别的锁和表级别的锁。")]),a._v(" "),s("li",[a._v("支持读写并发，写不阻塞读（MVCC）。")]),a._v(" "),s("li",[a._v("特殊索引存放方式，可以减少IO，提升查询效率。")])]),a._v(" "),s("p",[a._v("**Memory特点：**将所有数据存放在RAM中，也被称为堆引擎。")]),a._v(" "),s("ul",[s("li",[a._v("读写速度很快，但是数据库重启或者奔溃，数据会消失。只适合做临时表。")]),a._v(" "),s("li",[a._v("将数据存储在内存中。")])]),a._v(" "),s("h2",{attrs:{id:"_3-执行更新语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行更新语句"}},[a._v("#")]),a._v(" 3. 执行更新语句")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707213709186.png",alt:"image-20210707213709186"}}),a._v(" "),s("p",[a._v("**两阶段提交原因：**两阶段提交类似于分布式事务，如果不用两阶段无法保证redo log 和 bin log 的事务一致性。")]),a._v(" "),s("p",[s("strong",[a._v("在崩溃时，判断事务是否需要提交：")])]),a._v(" "),s("ul",[s("li",[a._v("bin log 无记录，redo log 无记录：在redo log 写之前crash，"),s("strong",[a._v("恢复操作-》回滚事务")]),a._v("；")]),a._v(" "),s("li",[a._v("bin log 无记录，redo log 状态为 prepare：在bin log 写完之前crash，"),s("strong",[a._v("恢复操作-》回滚事务")]),a._v("；")]),a._v(" "),s("li",[a._v("bin log 有记录，redo log 状态为 prepare：在bin log 写完提交事务之前的crash，"),s("strong",[a._v("恢复操作-》提交事务")]),a._v("；")]),a._v(" "),s("li",[a._v("bin log 有记录，redo log 状态为 commit："),s("strong",[a._v("正常完成事务，不需要恢复")]),a._v("；")])]),a._v(" "),s("h2",{attrs:{id:"_4-innodb架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-innodb架构"}},[a._v("#")]),a._v(" 4. InnoDB架构")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707214729557.png",alt:"image-20210707214729557"}}),a._v(" "),s("h3",{attrs:{id:"_1-内存结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存结构"}},[a._v("#")]),a._v(" 1.  内存结构")]),a._v(" "),s("h4",{attrs:{id:"buffer-pool"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool"}},[a._v("#")]),a._v(" Buffer Pool")]),a._v(" "),s("p",[a._v("Buffer Pool缓存的是页面信息，包括数据页、索引页。Buffer Pool默认大小128M，可以调整。"),s("code",[a._v("show variables like '%innodb_buffer_pool%';")])]),a._v(" "),s("p",[a._v("InnoDB用LRU算法管理缓冲池（链表实现，非传统LRU，分young和old区）。")]),a._v(" "),s("p",[s("strong",[a._v("预读机制")]),a._v("（read ahead）：InnoDB的数据页并不都是在访问的时候才缓存到buffer pool，而是使用预读机制")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("分为"),s("strong",[a._v("线性预读")]),a._v("和"),s("strong",[a._v("随机预读")]),a._v("；")])]),a._v(" "),s("li",[s("p",[a._v("这种预读机制，将可能用到的数据提前加载到buffer pool，提高了I/O性能，但也会导致内存空间占用更多；")])]),a._v(" "),s("li",[s("p",[a._v("更有效的清理缓存，LRU算法将list分为new sublist（5/8），old sublist（3/8）。即对buffer pool做冷热分离；")]),a._v(" "),s("ul",[s("li",[a._v("所有新数据加入到buffer pool，一律放在LRU List的old sublist的head；")]),a._v(" "),s("li",[a._v("old sublist的数据再次被访问后（"),s("code",[a._v("innodb_old_blocks_time=1")]),a._v(" ，1秒以后被访问数据才移动，防止造成缓存污染），移动到new sublist；")]),a._v(" "),s("li",[a._v("new sublist的数据长时间没被访问，移动到old sublist。访问new sublist后3/4区域的缓存页，会移动到前1/4区域；")]),a._v(" "),s("li",[a._v("将old sublist区tail的数据进行淘汰；")])]),a._v(" "),s("img",{staticStyle:{zoom:"70%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707221039253.png",alt:"image-20210707221039253"}})])]),a._v(" "),s("h4",{attrs:{id:"change-buffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer"}},[a._v("#")]),a._v(" Change Buffer")]),a._v(" "),s("p",[a._v("引入Buffer Pool后，在更新数据时，如果数据页在Buffer Pool中存在，那么直接更新。如果不存在，那是否意味着需要从磁盘加载到内存，再对内存的数据页进行操作？")]),a._v(" "),s("p",[a._v("由上述问题，引入了Change Buffer，提高了更新时的性能。Change Buffer是Buffer Pool一部分。")]),a._v(" "),s("p",[a._v("如果数据页不是唯一索引，不需要从磁盘加载索引页判断是不是重复（唯一性检查）。这种情况下可以先把（Insert、Update、Delete）记录在Buffer Pool，最后再记录到数据页（merge操作）。")]),a._v(" "),s("p",[a._v("**何时merge：**在访问这个数据页的时候、后台线程、数据库shut down、redo log写满时触发。")]),a._v(" "),s("h4",{attrs:{id:"adaptive-hash-index"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#adaptive-hash-index"}},[a._v("#")]),a._v(" Adaptive Hash Index")]),a._v(" "),s("h4",{attrs:{id:"redo-log-buffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-buffer"}},[a._v("#")]),a._v(" (Redo) Log Buffer")]),a._v(" "),s("p",[a._v("Redo Log并不是每次直接写入磁盘，而是在Buffer Pool里有一块内存区域（Log Buffer）专门用来记录即将要写入日志文件的数据，默认16M，可以节省磁盘I/O。")]),a._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707222228222.png",alt:"image-20210707222228222"}}),a._v(" "),s("p",[a._v("查看Log Buffer写入磁盘时间，"),s("code",[a._v("show variables like 'innodb_flush_log_at_trx_commit';")]),a._v(" 刷盘越快，越安全，但会消耗性能。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707222358467.png",alt:"image-20210707222358467"}}),a._v(" "),s("h3",{attrs:{id:"_2-磁盘结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-磁盘结构"}},[a._v("#")]),a._v(" 2. 磁盘结构")]),a._v(" "),s("p",[s("strong",[a._v("Tables、Indexes、Tablespaces、InnoDB Data Dictionary、Doublewrite Buffer、Redo Log、Undo Logs")])]),a._v(" "),s("p",[a._v("System Tablespace：InnoDB数据字典（存储表和索引的元数据）、双写缓冲、change buffer、undo logs，如果没有指定file-per-table，也包含用户创建的表和索引数据。")]),a._v(" "),s("p",[a._v("部分写失效，可以使用双写缓冲解决此问题。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210707231651763.png",alt:"image-20210707231651763"}}),a._v(" "),s("h2",{attrs:{id:"_5-后台线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-后台线程"}},[a._v("#")]),a._v(" 5. 后台线程")]),a._v(" "),s("p",[a._v("后台线程主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master thread、IO thread、purge thread、page cleaner thread。")]),a._v(" "),s("p",[a._v("master thread：负责刷新缓存数据到磁盘并协调调度其他后台进程。")]),a._v(" "),s("p",[a._v("IO thread：分为insert buffer、log、read、write进程。分别用来处理insert buffer、重做日志、读写请求的IO回调。")]),a._v(" "),s("p",[a._v("purge thread：用来回收undo页。")]),a._v(" "),s("p",[a._v("page cleaner thread：用来刷脏。")]),a._v(" "),s("h2",{attrs:{id:"_6-server层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-server层"}},[a._v("#")]),a._v(" 6. Server层")]),a._v(" "),s("h3",{attrs:{id:"_1-binlog"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-binlog"}},[a._v("#")]),a._v(" 1. binlog")]),a._v(" "),s("p",[a._v("binlog以事件的形式记录了所有DDL和DML语句，可以用来主从复制和数据恢复。没有固定文件大小。")]),a._v(" "),s("p",[a._v("查看binlog："),s("code",[a._v("show BINARY logs")]),a._v(" 、"),s("code",[a._v("show binlog events in 'xxx-bin.00001'")]),a._v("。")]),a._v(" "),s("p",[s("strong",[a._v("主从复制：")]),a._v("（放在同一个内网缓存，确保同步实时性）")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("master节点开启binlog（my.cnf）；")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("//")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("配置完后需要重启")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("log-bin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("/var/lib/mysql/mysql-bin")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("server-id")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("1001 (唯一标记，slave访问master时需要读取这个唯一id)")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("//")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("检验是否开启成功")]),a._v("\n1.是否存在mysql-bin日志文件\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("2.show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("variables like 'log_bin%'")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("在master节点创建一个用户repl，类似于白名单，支持访问数据复制；")])]),a._v(" "),s("li",[s("p",[a._v("在slave节点执行；")]),a._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1. 添加配置")]),a._v("\nchange master "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("to")]),a._v(" master_host"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'ip'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("master_user"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'repl'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("master_password"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'123'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("master_log_file"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'mysql.bin.00001'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("master_log_pos"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2. 启动slave")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("start")]),a._v(" slave\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 查看slave是否正常")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("show")]),a._v(" slave "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("status")]),a._v("\n参数：Slave_IO_Running:Yes、Slave_SQL_Running:Yes\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 如何查看master_log_file")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("show")]),a._v(" master "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("status")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br")])])])]),a._v(" "),s("p",[a._v("PS：可以使用阿里组件canel实现跨节点实现数据同步。")]),a._v(" "),s("h1",{attrs:{id:"三、mysql事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、mysql事务"}},[a._v("#")]),a._v(" 三、MySQL事务")]),a._v(" "),s("p",[a._v("事务：是数据库管理系统（DBMS）执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。单条（DDL：create、drop）和（DCL：grant、revoke）也会有事务。")]),a._v(" "),s("p",[a._v("MySQL中支持事务的存储引擎：NDB、InnoDB。")]),a._v(" "),s("p",[a._v("事务四大特性（存储引擎：InnoDB）：")]),a._v(" "),s("ul",[s("li",[a._v("原子性（Atomicity）：通过 undo log 实现原子性；")]),a._v(" "),s("li",[a._v("隔离性（Isolation）：普通 select 使用 MVCC，加锁 select 使用记录锁、间隙锁、临键锁。")]),a._v(" "),s("li",[a._v("持久性（Durability）：通过 redo log 和 double write buffer 来实现；")]),a._v(" "),s("li",[a._v("一致性（Consistent）：")])]),a._v(" "),s("h2",{attrs:{id:"_1-事务并发问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务并发问题"}},[a._v("#")]),a._v(" 1. 事务并发问题")]),a._v(" "),s("h3",{attrs:{id:"脏读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[a._v("#")]),a._v(" 脏读")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711150057134.png",alt:"image-20210711150057134"}}),a._v(" "),s("h3",{attrs:{id:"不可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[a._v("#")]),a._v(" 不可重复读")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711150128153.png",alt:"image-20210711150128153"}}),a._v(" "),s("h3",{attrs:{id:"幻读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[a._v("#")]),a._v(" 幻读")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711150146143.png",alt:"image-20210711150146143"}}),a._v(" "),s("p",[a._v("不可重复读和幻读区别：修改或者删除造成读不一致叫不可重复读，插入造成的读不一致叫幻读。")]),a._v(" "),s("h2",{attrs:{id:"_2-事务隔离级别-sql92标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务隔离级别-sql92标准"}},[a._v("#")]),a._v(" 2. 事务隔离级别（SQL92标准）")]),a._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CJy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210711150407153.png",alt:"image-20210711150407153"}})]),a._v(" "),s("p",[a._v("P1：脏读；P2：不可重复读；P3：幻读；")]),a._v(" "),s("p",[a._v("READ UNCOMMITTED（读未提交）：会出现脏读、不可重复读、幻读；")]),a._v(" "),s("p",[a._v("READ COMMITTED（已提交读）：会出现不可重复读、幻读；")]),a._v(" "),s("p",[a._v("REPEATABLE READ（可重复读）：会出现幻读；")]),a._v(" "),s("p",[a._v("SERIALIZABLE（串行化）：解决所有问题；")]),a._v(" "),s("h3",{attrs:{id:"_1-mysql-innodb隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql-innodb隔离级别"}},[a._v("#")]),a._v(" 1. MySQL InnoDB隔离级别")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711150820484.png",alt:"image-20210711150820484"}}),a._v(" "),s("h4",{attrs:{id:"lbcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lbcc"}},[a._v("#")]),a._v(" LBCC")]),a._v(" "),s("p",[a._v("解决读一致性两大方案之一。Lock Based Concurrency Control（LBCC），读取数据时锁定要操作的数据，不允许其他的事务进行修改。不支持并发读写，读多写小情况下非常影响性能。")]),a._v(" "),s("h4",{attrs:{id:"mvcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[a._v("#")]),a._v(" MVCC")]),a._v(" "),s("p",[a._v("解决读一致性两大方案之一。Multi Version Concurrency Control（MVCC），在修改数据之前建立一个快照，后续事务中只会读取这个快照。")]),a._v(" "),s("p",[s("strong",[a._v("MVCC原则：")])]),a._v(" "),s("ul",[s("li",[a._v("一个事务能看到的数据版本：\n"),s("ul",[s("li",[a._v("第一次查询之前已经提交的事务的修改；")]),a._v(" "),s("li",[a._v("本事务的修改；")])])]),a._v(" "),s("li",[a._v("一个事务不能看见的数据版本：\n"),s("ul",[s("li",[a._v("本事务第一次查询之后创建的事务（事务ID比我的事务ID大）；")]),a._v(" "),s("li",[a._v("活跃的（未提交的）事务修改；")])])])]),a._v(" "),s("p",[s("strong",[a._v("MVCC原理：")])]),a._v(" "),s("p",[a._v("InnoDB的事务都是有编号的，而且会不断递增。InnoDB为每行记录都实现了两个隐藏字段：DB_TRX_ID（事务ID）、DB_ROLL_PTR（回滚指针）。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711151934058.png",alt:"image-20210711151934058"}}),a._v(" "),s("p",[s("strong",[a._v("Read View（可见性视图）：")])]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711154259129.png",alt:"image-20210711154259129"}}),a._v(" "),s("p",[a._v("根据 Read View，事务判断可见性规则：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("从数据的最早版本开始判断（undo log）；")])]),a._v(" "),s("li",[s("p",[a._v("trx_id = creator_trx_id，本事务修改，可以访问；")])]),a._v(" "),s("li",[s("p",[a._v("trx_id < min_trx_id，说明这个版本在生成 ReadView 已经提交，可以访问；")])]),a._v(" "),s("li",[s("p",[a._v("trx_id > max_trx_id，说明这个版本是生成 ReadView 之后才开启的事务，不能访问；")])]),a._v(" "),s("li",[s("p",[a._v("min_trx_id < trx_id < max_trx_id，看是否在 m_ids 中，如果在不能访问；如果不在可以访问；")])]),a._v(" "),s("li",[s("p",[a._v("如果当前版本不可见，就找 undo log 链中的下一个版本；")])])]),a._v(" "),s("p",[a._v("RR 中 Read View 是事务第一次查询的时候建立。RC 中 Read View 是事务每次查询的时候建立的（无法解决幻读）。")]),a._v(" "),s("h2",{attrs:{id:"_3-innodb锁类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-innodb锁类型"}},[a._v("#")]),a._v(" 3. InnoDB锁类型")]),a._v(" "),s("ul",[s("li",[a._v("Shared and Exclusive Locks")]),a._v(" "),s("li",[a._v("Intention Locks")]),a._v(" "),s("li",[a._v("Record Locks")]),a._v(" "),s("li",[a._v("Gap Locks")]),a._v(" "),s("li",[a._v("Next-Key Locks")]),a._v(" "),s("li",[a._v("Insert Intention Locks")]),a._v(" "),s("li",[a._v("AUTO-INC Locks")]),a._v(" "),s("li",[a._v("Predicate Locks for Spatial Indexes")])]),a._v(" "),s("p",[a._v("行级别锁（Shared and Exclusive Locks）和表级别锁（Intention Locks），称为锁的基本模型。")]),a._v(" "),s("p",[a._v("Record Locks、Gap Locks、Next-Key Locks，称为锁的算法。")]),a._v(" "),s("p",[a._v("Insert Intention Locks，插入意向锁。")]),a._v(" "),s("p",[a._v("AUTO-INC Locks，自增锁。是一种特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等到事务提交才释放。"),s("code",[a._v("show variables like 'innodb_autoinc_lock_mode';")])]),a._v(" "),s("ul",[s("li",[a._v("0：traditional（每次都会产生表锁）")]),a._v(" "),s("li",[a._v("1：consecutive（会产生一个轻量锁，simple insert 会获得批量的锁，保证连续插入，默认值）")]),a._v(" "),s("li",[a._v("2：interleaved（不会锁表，来一个处理一个，并发最高）")])]),a._v(" "),s("p",[a._v("Predicate Locks for Spatial Indexes，数据类型的索引。")]),a._v(" "),s("h3",{attrs:{id:"共享锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[a._v("#")]),a._v(" 共享锁")]),a._v(" "),s("p",[a._v("Shared Locks（共享锁），行级别的锁。获取了一行数据的读锁，注意不要在加上读锁以后去写数据，可能会出现死锁的情况。多个事务可以共享一把读锁。")]),a._v(" "),s("p",[a._v("共享锁的作用：共享锁会阻塞其他事务的修改，所以可以用在不允许其他事物修改数据的情况。")]),a._v(" "),s("p",[s("code",[a._v("BEGIN; SELECT * from user where name = 'King' lock in share mode;")])]),a._v(" "),s("h3",{attrs:{id:"排它锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排它锁"}},[a._v("#")]),a._v(" 排它锁")]),a._v(" "),s("p",[a._v("Exclusive Locks（排它锁），行级别的锁。用来操作数据，所以又叫写锁。只要一个事务获取了一行数据的排它锁，其他事物就不能再获取这一行数据的共享锁和排它锁。")]),a._v(" "),s("p",[a._v("增删改默认自动加排它锁，"),s("code",[a._v("for update")]),a._v(" 手动加排它锁。")]),a._v(" "),s("h3",{attrs:{id:"意向锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[a._v("#")]),a._v(" 意向锁")]),a._v(" "),s("p",[a._v("意向锁由数据库自己维护。当我们给一行数据加上共享锁之前，数据库会自动在这张表上加上一个"),s("strong",[a._v("意向共享锁")]),a._v("。当我们给一行数据加上排它锁之前，会自动为这张表加上一个"),s("strong",[a._v("意向排它锁")]),a._v("。")]),a._v(" "),s("p",[a._v("**意向锁的作用：**在需要加表锁时，不必要进行全表扫描，只需要判断表上是否存在意向锁，如果有直接返回失败。如果没有，就可以加锁成功。")]),a._v(" "),s("h2",{attrs:{id:"_4-行锁的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-行锁的原理"}},[a._v("#")]),a._v(" 4. 行锁的原理")]),a._v(" "),s("p",[a._v("InnoDB 的行锁，是通过锁住索引实现的。")]),a._v(" "),s("p",[a._v("**一张表有没有可能没有索引：**①、如果定义了主键，那么 InnoDB 会选择主键作为聚集索引。")]),a._v(" "),s("p",[a._v("​\t\t\t\t\t\t\t\t\t\t\t②、如果没有显示定义主键，InnoDB 会选择一个不包含 NULL 值的唯一索引作为主键索引。")]),a._v(" "),s("p",[a._v("​\t\t\t\t\t\t\t\t\t\t\t③、如果没有这样的唯一索引，InnoDB 会选择内置6字节的 ROWID 作为隐藏的聚集索引。")]),a._v(" "),s("p",[a._v("**案例一：**为什么没有索引的表，锁住一行数据会导致锁表？")]),a._v(" "),s("p",[a._v("因为查询没有使用索引，会进行全表扫描，然后把每一个隐藏的聚集索引都锁住了。")]),a._v(" "),s("p",[a._v("**案例二：**为什么通过唯一索引给数据加行锁，主键索引也会被锁住？")]),a._v(" "),s("p",[a._v("因为唯一索引中存储的是主键的值，所以最终会根据主键的值去主键索引中搜索叶子节点存储的数据，进而导致主键索引也会被一同锁住。")]),a._v(" "),s("h2",{attrs:{id:"_5-锁的算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-锁的算法"}},[a._v("#")]),a._v(" 5. 锁的算法")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711214955375.png",alt:"image-20210711214955375"}}),a._v(" "),s("p",[a._v("整型的主键索引，它是可以排序的，主键索引不是整型是字符情况下也是有相应的排序规则。")]),a._v(" "),s("p",[a._v("Next-key Lock（临键锁） = Gap Lock（间隙锁） + Record Lock（记录锁）")]),a._v(" "),s("p",[a._v("InnoDB 的 RR 级别能够解决幻读的问题，就是用临键锁实现的。")]),a._v(" "),s("h2",{attrs:{id:"_6-死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-死锁"}},[a._v("#")]),a._v(" 6. 死锁")]),a._v(" "),s("p",[a._v("当多个事务形成等待环路的时候，即发生死锁。")]),a._v(" "),s("p",[s("strong",[a._v("查看锁日志信息（非实时）")]),a._v("："),s("code",[a._v("SHOW STATUS LIKE 'innodb_row_lock%';")])]),a._v(" "),s("ul",[s("li",[a._v("Innodb_row_lock_current_waits：当前正在等待锁定数量；")]),a._v(" "),s("li",[a._v("Innodb_row_lock_time：从系统启动到现在，锁定总时长，单位ms；")]),a._v(" "),s("li",[a._v("Innodb_row_lock_time_avg：每次等待所花平均时间；")]),a._v(" "),s("li",[a._v("Innodb_row_lock_time_max：从系统启动到现在，最长一次等待时间；")]),a._v(" "),s("li",[a._v("Innodb_row_lock_waits：从系统启动到现在，总共发生等待次数；")])]),a._v(" "),s("p",[s("strong",[a._v("当前运行的所有事务")]),a._v("："),s("code",[a._v("SELECT * FROM information_schema.INNODB_TRX;")])]),a._v(" "),s("p",[a._v("如果一个事务长时间不释放锁，可以 kill 事务的线程ID。")]),a._v(" "),s("h1",{attrs:{id:"四、mysql性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、mysql性能优化"}},[a._v("#")]),a._v(" 四、MySQL性能优化")]),a._v(" "),s("h2",{attrs:{id:"_1-连接-配置优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接-配置优化"}},[a._v("#")]),a._v(" 1. 连接-配置优化")]),a._v(" "),s("p",[s("strong",[a._v("服务端：")]),s("code",[a._v("error 1040:Too many connections")]),a._v(" 错误，超过了服务端设置的最大并发连接数。")]),a._v(" "),s("ul",[s("li",[a._v("增加服务端连接数。"),s("code",[a._v("SHOW VARIABLES LIKE 'max_connections';")])]),a._v(" "),s("li",[a._v("及时释放不活动的连接。"),s("code",[a._v("SHOW GLOBAL VARIABLES LIKE 'wait_timeout';")])])]),a._v(" "),s("p",[s("strong",[a._v("客户端：")])]),a._v(" "),s("ul",[s("li",[a._v("引入连接池池，连接池并不是越大越好（CPU核数*2+1）。DBCP、C3P0、Druid、Hikari。")])]),a._v(" "),s("h2",{attrs:{id:"_2-架构优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-架构优化"}},[a._v("#")]),a._v(" 2. 架构优化")]),a._v(" "),s("h3",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[a._v("#")]),a._v(" 缓存")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712222513156.png",alt:"image-20210712222513156"}}),a._v(" "),s("h3",{attrs:{id:"集群、主从复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集群、主从复制"}},[a._v("#")]),a._v(" 集群、主从复制")]),a._v(" "),s("p",[a._v("通过读写分离方案。")]),a._v(" "),s("img",{staticStyle:{zoom:"70%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712222710462.png",alt:"image-20210712222710462"}}),a._v(" "),s("h3",{attrs:{id:"分库分表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[a._v("#")]),a._v(" 分库分表")]),a._v(" "),s("p",[s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712222812629.png",alt:"image-20210712222812629"}}),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712222828995.png",alt:"image-20210712222828995"}})]),a._v(" "),s("h2",{attrs:{id:"_3-优化器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-优化器"}},[a._v("#")]),a._v(" 3. 优化器")]),a._v(" "),s("h3",{attrs:{id:"慢日志查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#慢日志查询"}},[a._v("#")]),a._v(" 慢日志查询")]),a._v(" "),s("p",[s("code",[a._v("SHOW VARIABLES LIKE 'slow_query%';")]),a._v(" "),s("code",[a._v("SHOW VARIABLES LIKE '%long_query%';")])]),a._v(" "),s("p",[a._v("①：使用 set 方式修改，MySQL重启后就失效了。②：修改配置文件 my.cnf")]),a._v(" "),s("h3",{attrs:{id:"慢日志分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#慢日志分析"}},[a._v("#")]),a._v(" 慢日志分析")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("查看慢日志："),s("code",[a._v("less LAPTOP-RD1J2F11-slow.log")])])]),a._v(" "),s("li",[s("p",[a._v("使用工具："),s("code",[a._v("mysqldumpslow -s t -t 10 -g 'select' LAPTOP-RD1J2F11-slow.log;")])])])]),a._v(" "),s("h3",{attrs:{id:"查看服务器状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看服务器状态"}},[a._v("#")]),a._v(" 查看服务器状态")]),a._v(" "),s("p",[a._v("运行线程："),s("code",[a._v("SHOW FULL PROCESSLIST;")])]),a._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CJy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210712224346573.png",alt:"image-20210712224346573"}})]),a._v(" "),s("p",[a._v("查看服务器状态："),s("code",[a._v("SHOW GLOBAL STATUS;")])]),a._v(" "),s("p",[a._v("存储引擎运行状态："),s("code",[a._v("SHOW ENGINE INNODB STATUS;")])]),a._v(" "),s("p",[a._v("开启 InnoDB 监控："),s("code",[a._v("SET GLOBAL innodb_status_output=ON;")]),a._v(" "),s("code",[a._v("SET GLOBAL innodb_status_output_locks=ON;")])]),a._v(" "),s("h3",{attrs:{id:"explain"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#explain"}},[a._v("#")]),a._v(" EXPLAIN")]),a._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CJy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210712225212768.png",alt:"image-20210712225212768"}})]),a._v(" "),s("p",[a._v("id：id值不同，先大后小；id值相同，从上往下；")]),a._v(" "),s("p",[a._v("select_type：SIMPLE-简单查询；PRIMARY-主查询；SUBQUERY-子查询；DERVIED-衍生查询，用到临时表；....")]),a._v(" "),s("p",[a._v("type："),s("code",[a._v("system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL")]),a._v(" 除了ALL 都能用索引。")]),a._v(" "),s("ul",[s("li",[a._v("const：主键索引或唯一索引，智能查到一条数据；")]),a._v(" "),s("li",[a._v("eq_ref：通常出现多表 join 查询，被驱动表通过唯一性索引查询，此时被驱动表就是eq_ref；")]),a._v(" "),s("li",[a._v("ref：用到了非唯一性索引，或者关联操作只使用了索引的最左前缀；")]),a._v(" "),s("li",[a._v("range：使用索引范围扫描；")]),a._v(" "),s("li",[a._v("index：查询全部索引中的数据；")]),a._v(" "),s("li",[a._v("all：没有用索引；")])]),a._v(" "),s("p",[a._v("key_len：索引的长度，跟索引类型、长度有关。")]),a._v(" "),s("p",[a._v("filtered：存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例。")]),a._v(" "),s("p",[a._v("Extra：执行计划给出的额外信息。")]),a._v(" "),s("ul",[s("li",[a._v("using index：用到了覆盖索引，不需要回表；")]),a._v(" "),s("li",[a._v("using where：使用了 where 过滤，表示存储引擎返回的数据并不是所有都满足，需要在 server 层进行过滤；")]),a._v(" "),s("li",[a._v("using index condition：索引条件下推；")]),a._v(" "),s("li",[a._v("using filesort：不能使用索引排序，用到了额外的排序，"),s("strong",[a._v("需要优化")]),a._v("；")]),a._v(" "),s("li",[a._v("using temporary：用到临时表；（distinct、group by、join）")])]),a._v(" "),s("h3",{attrs:{id:"sql与索引优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sql与索引优化"}},[a._v("#")]),a._v(" SQL与索引优化")]),a._v(" "),s("p",[a._v("例如："),s("code",[a._v("SELECT * FROM user LIMIT 10000000, 10;")]),a._v("  -》 "),s("code",[a._v("SELECT * FROM user WHERE id > 10000000 LIMIT 10;")]),a._v(" 先走 id 索引，再获取10条数据。")]),a._v(" "),s("h2",{attrs:{id:"_4-存储引擎和表结构优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-存储引擎和表结构优化"}},[a._v("#")]),a._v(" 4. 存储引擎和表结构优化")]),a._v(" "),s("p",[a._v("并发大更新多：InnoDB；临时表：Memeroy；考虑分表；字段使用正确存储数据的最小数据类型。非空字段尽量定义成 NOT NULL。不要用外键、触发器、视图。")]),a._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\Jy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712232502891.png",alt:"image-20210712232502891"}})])}),[],!1,null,null,null);t.default=e.exports}}]);